# Copyright (c) 2020-2021 Advanced Robotics at the University of Washington <robomstr@uw.edu>
#
# This file is part of Taproot.
#
# Taproot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Taproot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Taproot.  If not, see <https://www.gnu.org/licenses/>.

import sys
import copy
from typing import Set, Dict, Tuple
from collections import defaultdict
sys.path.append(repopath("lbuild-scripts"))
import board_info_parser

def extractPinDefines(pins):
    pins = [pin.strip() for pin in str.split(pins, ",")]
    return [] if pins == [""] else pins

class Analog(Module):
    def __init__(self, metadata):
        self.metadata = metadata
        
    def init(self, module):
        module.name = ":communication:gpio:analog"

    def prepare(self, module, options):
        module.depends(":board")
        return True

    def build(self, env):
        user_pins = extractPinDefines(env[":board:analog_in_pins"])

        # Collect adcs
        adcs = set()
        pin_to_adc: Dict[str, Set[str]] = defaultdict(set)
        pin_to_in: Dict[str, str] = {}
        for pin in self.metadata.find("gpio-pins"):
            pin_name = pin.get("alias")
            if pin_name in user_pins:
                pin_adcs = list(filter(lambda x: x.tag == "adc", pin.getchildren()))
                if pin_adcs == []:
                    raise RuntimeError(f"Invalid analog pin specified (pin {pin})")

                for adc in pin_adcs:
                    adc_id = adc.get("id")
                    adc_in = adc.get("in")
                    pin_to_adc[pin_name].add(adc_id)
                    pin_to_in[pin_name] = adc_in
                    adcs.add(adc_id)

        # Find how often each adc used
        adc_counts = dict()
        for adc in adcs:
            adc_counts[adc] = len(list(filter(lambda x: adc in x, pin_to_adc.values())))
        # Sort adcs such that those used more often are allocated to pins first, if adcs have same number of
        # pins, use smaller adc number
        adcs = sorted(adc_counts, key=lambda x: (adc_counts[x], -int(x)), reverse=True)

        # Add list of pins associated with each ADC
        adc_to_pin_map = {}
        user_pins_to_handle = copy.deepcopy(user_pins)
        for adc in adcs:
            pins_associated_with_adc = set()
            for pin in user_pins_to_handle:
                if adc in pin_to_adc[pin]:
                    pins_associated_with_adc.add(pin)
            user_pins_to_handle = list(filter(lambda x: x not in pins_associated_with_adc, user_pins_to_handle))
            adc_to_pin_map[adc] = list(pins_associated_with_adc)

        adc_to_pin_map = dict(filter(lambda x: x[1] != [], adc_to_pin_map.items()))
        adcs = list(filter(lambda x: x in adc_to_pin_map.keys(), adcs))

        env.substitutions = {
            "pins": user_pins,
            "adcs": adcs,
            "pin_to_adc": pin_to_adc,
            "pin_to_in": pin_to_in,
            "adc_to_pin_map": adc_to_pin_map
        }
        env.outbasepath = "taproot/src/tap/communication/gpio"
        env.template("analog.cpp.in", "analog.cpp")
        env.template("analog.hpp.in", "analog.hpp")

class Digital(Module):
    def __init__(self, metadata):
        self.metadata = metadata

    def init(self, module):
        module.name = ":communication:gpio:digital"

    def prepare(self, module, options):
        module.depends(":board")
        return True

    def build(self, env):
        input_pins = listify(extractPinDefines(env[":board:digital_in_pins"]))
        output_pins = listify(extractPinDefines(env[":board:digital_out_pins"]))
        env.substitutions = {
            "input_pins": input_pins,
            "output_pins": output_pins,
        }
        env.outbasepath = "taproot/src/tap/communication/gpio"
        env.template("digital.cpp.in", "digital.cpp")
        env.template("digital.hpp.in", "digital.hpp")

class Leds(Module):
    # TODO update this module, remove hard coded LEDs.
    def init(self, module):
        module.name = ":communication:gpio:leds"

    def prepare(self, module, options):
        module.depends(":board")
        return True

    def build(self, env):
        env.outbasepath = "taproot/src/tap/communication/gpio"
        env.template("leds.cpp.in", "leds.cpp")
        env.template("leds.hpp.in", "leds.hpp")

class Pwm(Module):
    def __init__(self, metadata):
        self.metadata = metadata

    def init(self, module):
        module.name = ":communication:gpio:pwm"

    def prepare(self, module, options):
        module.depends(":board")
        return True

    def build(self, env):
        # Collect pins
        user_pins = listify(extractPinDefines(env[":board:pwm_pins"]))

        # Tuple first element is id, second is channel.
        pin_to_timer_and_ch: Dict[str, Set[Tuple[str, str]]] = defaultdict(set)
        chs = set()
        for pin in self.metadata.find("gpio-pins"):
            pin_name = pin.get("alias")
            if pin_name in user_pins:

                # Find all timers associated with pin
                pin_timers = list(filter(lambda x: x.tag == "timer", pin.getchildren()))
                if pin_timers == []:
                    raise RuntimeError(f"Tried to configure PWM pin that doesn't have associated timer (pin {pin_name})")
                
                for timer in pin_timers:
                    ch = timer.get("channel")
                    pin_to_timer_and_ch[pin_name].add((timer.get("id"), ch))
                    chs.add(ch)

        pin_to_timer = dict([(x[0], set(map(lambda y: y[0], x[1]))) for x in pin_to_timer_and_ch.items()])
        timers = set().union(*pin_to_timer.values())

        # Find how often each timer used
        timer_counts = dict()
        for timer in timers:
            timer_counts[timer] = len(list(filter(lambda x: timer in x, pin_to_timer.values())))
        # Sort timers such that those used more often are allocated to pins first, if timers have same number,
        # use smaller timer number
        timers = sorted(timer_counts, key=lambda x: (timer_counts[x], -int(x)), reverse=True)

        pin_to_single_ch_and_timer: Dict[str, Tuple[str, str]] = dict()
        user_pins_to_handle = copy.deepcopy(user_pins)
        for timer in timers:
            # Find all pins associated with the given timer
            pins_associated_with_timer = set()
            for pin in user_pins_to_handle:
                if timer in pin_to_timer[pin]:
                    pins_associated_with_timer.add(pin)

            # Remove pins from the list of those pins that need to be associated with a channel and timer
            user_pins_to_handle = list(filter(lambda x: x not in pins_associated_with_timer, user_pins_to_handle))

            for pin in pins_associated_with_timer:
                ch = next(filter(lambda x: x[0] == timer, pin_to_timer_and_ch[pin]))[1]
                pin_to_single_ch_and_timer[pin] = (timer, ch)

        timers = list(set().union(*list(map(lambda x: x[0], pin_to_single_ch_and_timer.values()))))

        env.substitutions = {
            "pins": user_pins,
            "timers": timers,
            "chs": chs,
            "pin_to_single_ch_and_timer": pin_to_single_ch_and_timer,
        }
        env.outbasepath = "taproot/src/tap/communication/gpio"
        env.template("pwm.cpp.in", "pwm.cpp")
        env.template("pwm.hpp.in", "pwm.hpp")

def init(module):
    module.name = ":communication:gpio"
    module.description = "Various GPIO HAL wrappers"

def prepare(module, options):
    module.depends(":core", ":board")

    metadata = board_info_parser.parse_board_info(options[":dev_board"])
    module.add_submodule(Analog(metadata))
    module.add_submodule(Digital(metadata))
    module.add_submodule(Leds())
    module.add_submodule(Pwm(metadata))

    return True

def build(env):
    pass
